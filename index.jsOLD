import { andThen, cond, pipe, over, lensProp, assoc, filter, collectBy, map, mapObjIndexed, view, replace } from "ramda"
import parsePath from "parse-path"
import undici from "undici"
import { readFile as readLocalFile, readdir } from "node:fs/promises"
import { statSync } from "fs"
import * as path from "path"
import parsers from "./parsers.js"
import { tap } from "ramda"
import { Buffer } from "node:buffer"

const getFormat =
  (href) => pipe
    ( parsePath(href)
    , view(lensProp("extname")) 
    , replace(/^\./,"")
    )

const getRetrievalMethod =
  (href) => pipe
    ( parsePath
    , view(lensProp("protocol")) 
    , cond
    (
      [ [ (x) => ["file"].includes(x.protocol) && statSync(x.href).isFile()
        , async (x) => ({...x, content: await readLocalFile(x.href)})
        ]

      , [ (x) => ["file"].includes(x.protocol) && statSync(x.href).isDirectory()
        , async (x) => ({...x, format: "json", content: await readDirectory(x.href)})
        ]

      , [ (x) => ["http", "https"].includes(x.protocol) && x.extname === "cbor"
        , async (x) => ({...x, content: await fetchRemoteFile(x.href)})
        ]

      , [ (x) => ["http", "https"].includes(x.protocol)
        , async (x) => ({...x, content: await readRemoteFile(x.href)})
        ]
      ]
    )
    )

const readRemoteFile = pipe
  ( undici.request
  , andThen( (x) => x.body.text() )
  )
const fetchRemoteFile = pipe
  ( undici.fetch
  , andThen( (x) => x.body.getReader().read())
  , andThen( ({done, value}) => value)
  )

const readDirectory =
  async (href) => { 

    const paths = await readdir(href)
    const files = map(load,paths)
//    console.log(files)
    return files//Buffer.from("{}")
  }

/*
const load = pipe
  (
  , getDocument
  , andThen(tap(console.log))
  , andThen(parse)
  , andThen(tap(console.log))
  )

const getDocument = cond
    (
      [ [ (x) => ["file"].includes(x.protocol) && statSync(x.href).isFile()
        , async (x) => ({...x, content: await readLocalFile(x.href)})
        ]

      , [ (x) => ["file"].includes(x.protocol) && statSync(x.href).isDirectory()
        , async (x) => ({...x, format: "json", content: await readDirectory(x.href)})
        ]

      , [ (x) => ["http", "https"].includes(x.protocol) && x.extname === "cbor"
        , async (x) => ({...x, content: await fetchRemoteFile(x.href)})
        ]

      , [ (x) => ["http", "https"].includes(x.protocol)
        , async (x) => ({...x, content: await readRemoteFile(x.href)})
        ]
      ]
    )
  */
loaders = mapObjIndexed( (v,k,o) => { (x) => {let retrievalType = getRetrievalMethod(x);} }, parsers )
/*
export const loadYaml = loaders["yaml"]
export const loadJson = loaders["json"]
export const loadToml = loaders["toml"]
export const loadHtml = loaders["html"]
export const loadXml  = loaders["xml"]
export const loadMd = loaders["md"]
export const loadCbor = loaders["cbor"]
export const loadDhall = loaders["dhall"]
*/

export const parseYaml = parsers["yaml"]
export const parseJson = parsers["json"]
export const parseToml = parsers["toml"]
export const parseHtml = parsers["html"]
export const parseXml  = parsers["xml"]
export const parseMd = parsers["md"]
export const parseCbor = parsers["cbor"]
export const parseDhall = parsers["dhall"]
